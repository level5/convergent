先排序，再计算。



1. [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)


2. [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/submissions/)


## 堆

1. [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/submissions/)


最简单的做法，排序，找到第K个元素
```java
class Solution {
  public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
  }
}

```

实际上不需要全部拍，可以选择排序排前k个元素。

实现略

其实是堆的使用场景，不需要排序所有的数。
```java
class Solution {
  public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(nums.length, (a, b) -> b - a);
    for (Integer n : nums) {
      priorityQueue.add(n);
    }
    for (int i = 1; i < k; i++) {
      priorityQueue.poll();
    }
    return priorityQueue.poll();
  }
}
```


#### 二叉树

1. [最深叶节点的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/submissions/)

开始想是先找到最深的节点，然后往上找。但是一想行不通：1. 没有到parent的指针，也没有好的方式来找到最深的叶子。

这个时候想着从上往下找，如果一个节点的两个子树深度一样，那么他肯定就是最近的公共祖先。很容易证明，因为公共祖先不可能在左子树，也不可能在右子树上。

所以递归往下找到第一个左子树深度等于右子树深度的节点，如果当前这个节点不是，就往比较深的树找。


```java

class Solution {
  public TreeNode lcaDeepestLeaves(TreeNode root) {

    int gap = deep(root.left) - deep(root.right);
    if (gap == 0) {
      return root;
    } else if (gap > 0) {
      return lcaDeepestLeaves(root.left);
    } else {
      return lcaDeepestLeaves(root.right);
    }
  }

  private int deep(TreeNode node) {
    if (node == null) {
      return 0;
    }

    return 1 + Math.max(deep(node.left), deep(node.right));
  }
}

```
