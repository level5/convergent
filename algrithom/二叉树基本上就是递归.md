# 二叉树基本上就是递归

1. [最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/submissions/)

找到最大值，生成节点，然后左右生成树就好了。

2. [最深叶节点的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/submissions/)

开始想是先找到最深的节点，然后往上找。但是一想行不通：1. 没有到parent的指针，也没有好的方式来找到最深的叶子。

这个时候想着从上往下找，如果一个节点的两个子树深度一样，那么他肯定就是最近的公共祖先。很容易证明，因为公共祖先不可能在左子树，也不可能在右子树上。

所以递归往下找到第一个左子树深度等于右子树深度的节点，如果当前这个节点不是，就往比较深的树找。

```java

class Solution {
  public TreeNode lcaDeepestLeaves(TreeNode root) {

    int gap = deep(root.left) - deep(root.right);
    if (gap == 0) {
      return root;
    } else if (gap > 0) {
      return lcaDeepestLeaves(root.left);
    } else {
      return lcaDeepestLeaves(root.right);
    }
  }

  private int deep(TreeNode node) {
    if (node == null) {
      return 0;
    }

    return 1 + Math.max(deep(node.left), deep(node.right));
  }
}

```
