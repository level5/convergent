通过一些题目，尽量慢放一下当时做题的时候怎么想到解法的。

### 题目1，上次的考题
题目的大概意思如下，如果描述没讲清楚，请去看一下截图：

一个数组表示货物每天的价格。通过一次买入再卖出可能的获利最大值是多少。货物买入之后，每天要1元租金。

例如:`[1, 4, 10]`,如果第一天买入，第三天卖出，获利就是第三天的价格减去第一天的价格，再减去两天的租金。`10 - 1 - 2 = 7`

数组长度: 0 < N <= 50000

货物价格: 0 <= K <= 300


##### 思路：

先通过阅读题目和例子，确保自己理解题目什么意思。

马上可以想到，第a天买入，第b天卖出的盈利是：
```
b天的价格 - a天的价格 -（b - a）
```

- 有时候题目中的公式是`b - a`还是`b - a + 1`不是那么容易想清楚。实在想不清楚，可以猜一个。然后套一个简单的例子看看到底是哪个更快。

回到公式，第一时间可以想到穷举就是所有的买入卖出的可能性都计算一下。一个双重循环：

```java
// 第j天买入，第i天卖出
int max = 0;
for(int i = 1; i < N; i++) {
  for (int j = 0; j < i; j++) {
    max = Math.max(max, prices[i] - prices[j] - (i - j));
  }
}

```

题目有输入取值范围，所以想到的时候算一下N的平方已经到了亿级别了。肯定会超时。所以这个方法要过。

上面这是过程应该是一个瞬时的过程，应该马上就到这一步了。

然后看到下面的价格取值是300以内，如果让算法到`300 * 50000`的水平的话，这题应该可以过。这个时候马上可以想到，内圈的循环不需要50000，而是300，因为只有300中价格，那么每种价格离i最近的那次盈利最多。

因此根据题目的暗示，可以很快得到一个可行的解题思路。


300种价格中离i最近的那次就是这个价格最后一次出现的位置了。这个时候使用的套路就是计数排序的套路了。这也是为啥说要知道计数排序的思路。然后计数可能会变化，有的是记录某个值出现的次数，也可以是记录某个值最后出现的位置。

而且计数的思路都不一定是需要你知道输入范围，比如不知道输入范围的时候，用Map来计数。这个时候只是每次读取变成了`logn`也还是可以接受的，当然一般这个时候就是我说的强行使用Map等数据结构来解题的情况，一般不是题目考的算法，但是也能勉强通过。

```java
int[] lastPositions = int[301];
for(int i = 0; i < lastPositions.length; i++) {
  lastPositions[i] = -1;
}

int max = 0;
for(int i = 0; i < N; i++) {
  for(int j = 0; j < prices[i]; j++) {
    max = Math.max(max, price[i] - j - (i - lastPositions[j]));
  }
  lastPositions[prices[i]] = i;
}
```

#### 关键点：

- 看取值区间，根据取值区间的提示找到思路。

- 学习过计数排序的套路，并能够运用（算法 5.1.1 455页）。


#### 继续

实际上在想上面的思路的过程中，会隐约的感受到并不需要计算这么多次。比如我当时就做的时候有个感觉是第i天的价格比第i+1天小很多，那么第i天肯定不是最大盈利了。

吃饭听国华说有一个n时间复杂度的解法，不过没听懂他说的一个变量表示持有货物，一个变量表示不持有货物啥意思。

下班后拿起纸笔静下心来思考了一下。从一个混沌的感觉，到把内层循环理解成第i天可能的最大盈利是怎么来的忘记，大概是硬想到的吧。

因为原来的双重循环，脑子里面理解是求所有的可能中的最大值，并没有一个第i天可能的最大盈利这个概念，想到第i天最大盈利这个概念之后，问题就好解决了。

可以这么理解。在第i天卖出的盈利是：
```
第i天的价格 - 手里货物的成本
```

在第i天卖出的最大的盈利是：
```
第i天的价格 - 手里货物可能的最低成本
```

在第i天卖出，假设可能获取到的最大盈利是x，持有货物的最低成本是y。

那么在第i + 1天准备卖出的时候，这个成本y就变成了y+1， 如果第i天价格+1，小于y+1，那么最低成本就变成了第i天的价格+1，如果大于y+1，那么最低成本就是y+1。那么在第i+1天卖出的最大盈利就是：

```
第i+1天的价格 - (Math.min(y， 第i天的价格) + 1)

```


所以解法就是：

```java
int maxProfit = 0;
int minCost = prices[0] + 1;
for (int i = 1; i < N; i++) {
  maxProfit = Math.max(maxProfit, prices[i] - minCost);
  minCost = Math.min(minCost, prices[i]) + 1;
}
```

然后再回过头去看，如果是这个解法，把货物的价格限定在300以内是没有任何意义的。就更说明把货物价格限定在300是希望解题者至少想到面前的那种解法。

#### 总结

- 我们想问题，容易陷入想一个算法来一个怎么来得到解。有时候可以换个思路，不要去想怎么来得到正确答案。而是假设一个正确答案在哪里，然后去分析这个正确答案可能具有的特性。这个过程类似于高中数学的数学归纳法。找到这个特性，然后对于n = 1时，结果是肯定的，有n = 1逐步增加，求出n = N的解。

- 有时候可能把一个问题的求解，转换成另外一个问题的求解。这个转换是关键。比如，这个求可能的最大盈利，转换成求每一天卖出可能的最大盈利。

#### 再看一道类似的题来说明另外一个套路

[买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

To Be Continue...
