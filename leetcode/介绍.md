## 说明

leetcode集中刷了50多题，主要都是中等难度。总结一些经验。感觉顺利的话，除了个别有难度的，应该看完题就能想到思路。30分钟到1小时应搞定两道中等难度是可以的。

- 配置好测试框架来添加用例，这样可以保证添加多个用例，都能够在改动之后被执行。用main来跑，体验没这么好。

- 确保在SDK中找到解题常用的数据结构和算法。

  - 一个通用的排序算法。Java是针对数组和List

  - 二分查找算法

  - List，Map，Set

  - 有tuple更好，没有的话就只能用数组代替了。

  - 堆，MaxPQ，MinPQ

  - Stack，Queue（LinkedList）

  常用的基本就是这些。

- 需要懂的数据结构：
  - 位运算，有些时候，通过位运算来处理一些特殊情况很有用。不要忘记，对数字除了可以做加减乘除操作，还可以做位操作。
  - 排序
    - 计数排序
    - 插入排序
  - 堆
    - 堆排序
    - MaxPriorityQueue，Go Heap的文档中有实现的代码，可以先拷贝下来。

  - 树

    - dfs
    - bfs

  - 图, 这部分我感觉不大会有中等题中出现，出现了一般也不会太复杂。保险起见，可以系统学习一下。图的算法一般都实现简单，但是理解需要花一点时间。

- 需要懂得算法思想

  - 熟练使用递归，熟练将题目转化成递归表达。大部分的穷举法转换成递归能够便于理解和实现。效率太差的情况下，再配合上memorized的，效果还是很好的。

  - 动态规划题也很多。知道什么情况下不能够用动态规划。

- 中等难度的题，不会太难，一般就是一个知识点。 如果自己实现思路，需要写很复杂的代码，做复杂的处理，写的代码太长，估计就不是最优实现了。

  看了一下自己完成的题，大部分是2x ~ 3x行解决。小部分4x ~ 6x行解决（这部分不是最优方式，不能做到打败9x%）。所以感觉一般中等题考的点，都能通过3x行内的代码来解决。再多的话，就是自己思路不对。

  并且而且一般来说，不会需要对很多特殊情况做检查来处理，一般特殊情况都能在通用的算法中解决掉的。

- 仔细看题，特别是描述复杂的题，确保理解清楚，避免出错了需要回过头来再看题。

  出现过几次这样的情况。有一道题思路花了几分钟就有了，但是实现下来花了快一小时才搞定，就是因为看题看漏了，然后又过度在细节上做优化了。

- 尽量代码一次性写对，因为考试没有测试用例。不知道错在哪里，即使有测试用例，如果出错在一个很大的输入集上的时候，调试基本上也属于不可能。这个时候如果100%确认思路没问题，可以走读代码发现错误的。如果都不知道自己的思路是不是确实100%正确，那就不好办了。

  所以要避免在解题思路确定的情况下，在代码细节上的优化。细节上的优化不会从数量级上减少执行时间。如果超时了，细节优化也没办法改变。所以怎么写不出错就怎么写。

- 最后的输入范围能够起到提示作用。需要自己能够大概提前根据范围，自己想到的实现，提前估算一下是否有可能超时。避免实现之后，超时了。浪费大量时间还造成心理压力。

  - 范围很小，比如n一百以内，或者几百，这种基本上就是提示使用穷举法来做。

  - 范围一万， 十万左右，这基本上就是告诉你穷举法不行。n的平方的搞不定了，至少得到nlongn，类似于先排序，然后再处理。

  - 范围是10亿级别的，基本上表示需要使用更优化的算法，O(n)也不行，需要透过题目的描述，发现一些规律或者本质的东西。

  如果第一眼没有完全没有思路，结合参数范围和题目中具体给出的例子，看看输入和输出的规律。有助于找到一些思路。

- 有一些题，想不出正确的解法，可以使用Map，Heap，Set这些数据结构，利用这些数据结构的高效，强行来解决问题。有时候也可以勉强让题目通过。



### 排序

几万几十万的输入集，穷举法基本的复杂度至少上是n的平方。基本上很大的可能性就是超时了。有时候可以可以先通过排序，然后基于排序后的结果来求解。

一个比较典型的例子就是[三数之和](https://leetcode-cn.com/problems/3sum/submissions/)。

对于这个问题，一上来暴力求解，复杂度就是n的三次方。这个基本就可以确定超时了。如果排序之后。第三个循环使用二分查找来搜索，就可以变成n的平方乘以logn。

对于排序，使用SDK自带排序算法就好，可以默认一般情况下时间复杂度就是n乘以logn。大概知道一下基本的排序实现原理就好。

有一部分排序需要掌握，某些题可能用到这些思想。

- 计数排序

  输入集有限的情况下，可以先循环一遍，统计每个输入出现次数。然后第二遍按这个统计结果直接插入到正确的位置。

  这个经常用到的就是对于小的输入集合，怎么用计数的方式来处理。

- 插入排序

  和扑克牌抓拍的原理相似。手上的牌是已经排序的。然后抓起一张新的牌，插入到手上，保持手中的牌是有序的。

- 堆排序

  理解怎么构建的堆，堆的特点。以及怎么实现元素上浮和下沉。实际可以直接使用SDK提供`PriorityQueue`。go可以复制文档中的实现提前准备。


1. [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

2. [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/submissions/)

1. [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/submissions/)


### 二叉树

掌握dfs和bfs就好了。平衡二叉树太难，不用管。

中等难度的题的话，基本上就是写一个递归算法，分治法或者减治法。做了10道相关的题，都是这个套路。关键点就是怎么把问题转化成左右子树的表达式。

1. [最深叶节点的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/submissions/)

### 动态规划

...

### 图

...
