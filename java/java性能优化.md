# Java性能优化

性能问题，在分析阶段需要考虑的问题:
- 应用预期吞吐量
- 请求和响应之间的延迟预期
- 应用支持的并发任务
- 最大并发情况下，可接受的吞吐量和延迟
- 最差情况下的延迟
- 垃圾回收引入的延迟在可容忍范围之内，垃圾收集的频率

性能分析的两种方式
* 自顶向下
* 自底向上

### 操作系统性能监控

#### CPU使用率
- 对于计算密集型应用，减少停滞，改善CPU高速缓存，可以减少CPU等待内存的时间。
- Window： Task Manager和performance Monitor
- Linux：GNOME System Monitor

##### CPU调度程序运行队列
CPU调用程序运行队列就是等待可用CPU的轻量级进程。当运行队列长度达到虚拟处理器的4倍或者更多时，系统的响应就非常迟缓了.

很长一段时间内一直超过一倍，需要关注；很长一段时间达到3~4倍，需要引起注意和采取行动.

这里还可以用jstack监控，查看是否有很多线程空闲等待在那里，如果是，可以减少线程数量，来减少线程上下文切换所带来的性能损失.

此时采取的行动：
* 增加CPU
* 改进CPU使用率，研究可以减少应用运行所需要CPU周期的方法（TODO:举例说明）
  * 如减少垃圾回收的频率
  * 改进应用数据结构和算法

#### 内存使用率
内存相关的属性（TODO: 具体说明）：
- 页面调度
- 页面交换
  * 应用的响应性和吞吐两造成影响
  * JVM垃圾回收性能造成影响  
- 加锁
- 线程迁移中的让步式和抢占式上下文切换
   * 抢占式上下文切换率高表明预备运行的线程数多于咳哟过的虚拟处理器
   * 运行线程从一个CPU切换到另外一个CPU也会导致性能下降

#### 网络I/O使用率
单次读取数据量小，而网络读写量大得应用会消耗大量的系统态CPU。
- 减少网络读写的系统调用
- 使用非阻塞的Java NIO
- 减少处理请求和发送响应的线程数
- 非阻塞socket读取数据的策略师，每次读请求时尽可能多地读取数据
- 每次socket写数据尽可能多地写数据
- 这里的含义就是尽可能使用Java NIO框架，如Grizzly项目，而不是使用JDK提供的Java NIO

#### 磁盘I/O使用率
I/O使用率高的话，值得深入分析系统磁盘I/O子系统的性能
- 更快的存储设备
- 文件系统扩展到多个磁盘
- 操作系统调优，是的可以桓曾大量的文件系统数据结构
- 确保磁盘缓存是开启状态
- 应用角度，减少磁盘活动
  * 如使用带缓存的输入输出

### JVM性能监控

#### 垃圾回收
垃圾回收机制（TODO： 稍微做一点说明各种垃圾回收机制）：
- serial
- Parallel（Throughput）
- CMS
- G1

应用程序对垃圾回收的影响（TODO：具体说明一下）：
- 内存分配，当分代的占用达到某个限额时，就会发生垃圾回收。应用的内存分配速率越高，垃圾回收触发就越频繁
  * Eden满时，发生Minor GC
  * 老年代占用超过CMS初始限额会发生CMS
- 存活数据的多少，Java堆中存活的对象越多，收集器需要做的工作就越多
- 老年代中引用更新，这样在下一轮Minor GC就需要处理

对垃圾回收的监控
当前使用的垃圾回收机制
- Java堆的大小
- 新生代和老年代的大小
- 永久代的大小
- Minor GC的持续时间
- Minor GC的频率
- Minor GC的空间回收量
- Full GC的持续时间
- Full GC的频率
- 每个并发垃圾回收周期的空间回收量
- 垃圾回收前后Java堆得占有量
- 垃圾回收前后新生代和老年代的占有量
- 垃圾收集前后永久带的占有量
- 是否老年代或者永久带的占用出发了Full GC
- 应用是否显式调用了System.GC()

垃圾回收开销：
- GCHisto
- Stop-The-Word数据
- Young GC, MajorGC, Initial Mark, Remark
- 垃圾回收的开销应该小于10%， 也可能达到1~3%。
- 对于Throughput回收器，可以接近1%，3%或者更高说明可以改善
- Java堆越大，降低垃圾回收开销的机会越大
- 最长停顿时间（Maximum Pause Time）
- 评估最差情况下是否满足应用需求
- 类加载的监控，类被加载到永久代，当永久代空间不足是，就会发生Full GC，将没有使用的类从永久代移除。

#### Java应用监控
监控锁竞争
- jstack
- 从多个线程的栈追踪信息中查找相同的锁地址，然后找到在等待该锁地址的线程。如果发现多个线程的栈追踪嘻嘻都试图锁住相同的锁地址，说明应用正面临锁竞争。
- 抓取多分jstack日志，如果同一个锁上一直出现类似锁竞争，说明应用可能正面临高度锁竞争。

TODO
性能分析

方法分析

Java应用性能分析技巧

性能优化归结为下面几类：
- 使用更高效的算法
- 减少锁争用
- 为算法生成更有效的代码

### JVM性能调优

#### 垃圾回收机制
